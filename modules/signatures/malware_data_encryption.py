# Copyright (C) 2019 ditekshen
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from lib.cuckoo.common.abstracts import Signature


class EncryptPCInfo(Signature):
    name = "encrypt_pcinfo"
    description = "Collects and encrypts information about the computer likely to send to C2 server"
    severity = 1
    categories = ["c2", "encryption"]
    authors = ["Kevin Ross"]
    minimum = "0.5"
    evented = True
    ttps = ["T1022"]  # MITRE v6
    ttps += ["T1033"]  # MITRE v6,7,8
    ttps += ["T1560"]  # MITRE v7,8
    mbcs = ["OB0007"]

    filter_apinames = set(["CryptEncrypt", "CryptHashData", "GetComputerNameW", "GetUserNameW"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.ret = False
        self.compname = str()
        self.username = str()
        self.buffers = set()
        self.safelistprocs = ["winword.exe", "excel.exe", "powerpnt.exe"]

    def on_call(self, call, process):
        if process["process_name"].lower() not in self.safelistprocs:
            if call["api"] == "GetComputerNameW":
                self.compname = self.get_argument(call, "ComputerName")

            if call["api"] == "GetUserNameW":
                self.username = self.get_argument(call, "Name")

            if call["api"].startswith("Crypt"):
                buff = self.get_argument(call, "Buffer")
                if buff and (self.username or self.compname):
                    if self.compname.lower() in buff.lower() or self.username.lower() in buff.lower():
                        self.ret = True
                        self.buffers.add(buff)
                        if self.pid:
                            self.mark_call()

    def on_complete(self):
        for buffer in self.buffers:
            self.data.append({"data_being_encrypted": buffer})
        return self.ret


class EnryptDataAgentTeslaHTTP(Signature):
    name = "encrypt_data_agenttesla_http"
    description = "AgentTesla HTTP variant keylogger detected encrypting data potentially prior to exfiltrating it"
    severity = 3
    categories = ["keylogger", "infostealer"]
    families = ["AgentTesla"]
    authors = ["ditekshen"]
    minimum = "0.5"
    evented = True
    ttps = ["T1022"]  # MITRE v6
    ttps += ["T1560"]  # MITRE v7,8
    mbcs = ["OB0010", "E1560", "E1560.m02"]
    mbcs += ["OC0005", "C0027"]  # micro-behaviour

    filter_apinames = set(["CryptEncrypt"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.match = False

    def on_call(self, call, process):
        buff = self.get_argument(call, "Buffer")
        if buff:
            if "type=" in buff and "hwid=" in buff and "pcname=" in buff:
                self.match = True
                self.data.append({"data": buff})

    def on_complete(self):
        return self.match


class EnryptDataNanoCore(Signature):
    name = "encrypt_data_nanocore"
    description = "NanoCore keylogger detected encrypting data potentially prior to exfiltrating it"
    severity = 3
    categories = ["keylogger", "infostealer"]
    families = ["NanoCore"]
    authors = ["ditekshen"]
    minimum = "0.5"
    evented = True
    ttps = ["T1022"]  # MITRE v6
    ttps += ["T1560"]  # MITRE v7,8
    mbcs = ["OB0010", "E1560", "E1560.m02"]
    mbcs += ["OC0005", "C0027"]  # micro-behaviour

    filter_apinames = set(["CryptEncrypt", "GetComputerNameW", "GetUserNameW"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.username = str()
        self.hostname = str()
        self.match = False

    def on_call(self, call, process):
        if call["api"] == "GetComputerNameW":
            self.hostname = self.get_argument(call, "ComputerName")
        if call["api"] == "GetUserNameW":
            self.username = self.get_argument(call, "Name")
        if call["api"] == "CryptEncrypt":
            buff = self.get_argument(call, "Buffer")
            if buff:
                if buff.startswith("\\x00\\x00\\x00\\x00\\x12") and "\\x0c\\x07" in buff:
                    if self.hostname and self.username:
                        combo = self.hostname + "\\" + self.username
                        if combo in buff:
                            self.match = True
                            if self.pid:
                                self.mark_call()

    def on_complete(self):
        return self.match


class EnryptDataAgentTeslaHTTPT2(Signature):
    name = "encrypt_data_agentteslat2_http"
    description = "AgentTesla v2 HTTP variant keylogger detected encrypting data potentially prior to exfiltrating it"
    severity = 3
    categories = ["keylogger", "infostealer"]
    families = ["Predator"]
    authors = ["ditekshen"]
    minimum = "0.5"
    evented = True
    ttps = ["T1022"]  # MITRE v6
    ttps += ["T1560"]  # MITRE v7,8
    mbcs = ["OB0010", "E1560", "E1560.m02"]
    mbcs += ["OC0005", "C0027"]  # micro-behaviour

    filter_apinames = set(["CryptEncrypt", "GetComputerNameW", "GetUserNameW"])

    def __init__(self, *args, **kwargs):
        Signature.__init__(self, *args, **kwargs)
        self.username = str()
        self.hostname = str()
        self.match = False

    def on_call(self, call, process):
        if call["api"] == "GetComputerNameW":
            self.hostname = self.get_argument(call, "ComputerName")
        if call["api"] == "GetUserNameW":
            self.username = self.get_argument(call, "Name")
        if call["api"] == "CryptEncrypt":
            buff = self.get_argument(call, "Buffer")
            if buff:
                if (
                    "22afd24bbac47acb3f315177181b7d3cb7cd0270291f14b3" in buff
                    or "0801a7d44564d53e2d9e9871eae7aab021d0180ac9f508" in buff
                ):
                    if self.hostname and self.username:
                        combo = self.hostname + "/" + self.username
                        if combo in buff:
                            self.match = True
                            if self.pid:
                                self.mark_call()

    def on_complete(self):
        return self.match
